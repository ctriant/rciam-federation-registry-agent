#!/usr/bin/env python3

import json, time
import subprocess
import argparse
import requests
import logging
from common import get_log_conf
from ServiceRegistryAms.PullPublish import PullPublish

log = logging.getLogger(__name__)

def init_ams_agent(path):
    log.info('Init ams agent')
    with open(path) as json_data_file:
        config = json.load(json_data_file)
    return PullPublish(config)

'''
This function will return the altered current state and new additions to it
    Function update_data gets 2 arguments:
    - services, current state included in the php metadata file in json
    - messages, the new incoming messages in json
'''
def update_data( services, messages ):
    new_services = []
    for msg in messages:
        log.info('Update service: ' + msg['id'])
        if msg['deployment_type'] == 'create':
            new_services.append({'registry_service_id': msg['id'], 'whitelist': [msg['entity_id']], 'src': msg['metadata_url']})
        elif msg['deployment_type'] == 'edit':
            for service in services:
                if service['registry_service_id'] == msg['id']:
                    service['whitelist'] = [ msg['entity_id'] ]
                    service['src'] = msg['metadata_url']
                    break
        elif msg['deployment_type'] == 'delete':
            for service in services:
                if service['registry_service_id'] == msg['id']:
                    services.remove(service)
                    break
    return services + new_services

'''
This function get the current state and will generate a configuration
php file with the updated state
    generate_config gets 2 arguments:
    - services, which represents the current state in json
    - path, which is the location of the config file
'''
def generate_config( services, path ):
    log.info('Generate php ssp config file at ' + path)
    header = """<?php
return array("""
    footer = """
);"""
    content = ""
    for service in services:
        content += """
    array(
        'registry_service_id' => """ + str(service['registry_service_id']) + """,
        'whitelist' => array (
            '"""+ str(service['whitelist'][0])  +"""',
        ),
        'src' => '""" + str(service['src']) + """',
    ),"""
    f = open(path,"w")
    f.write(header+content+footer)
    f.close()
    



if __name__ == '__main__':
    # Get config path from arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', required=True, type=str, help="Script configuration file path")
    args = parser.parse_args()
    path = args.c
    with open(path) as json_data_file:
        config = json.load(json_data_file)
    get_log_conf(config['log_conf'])


    ams = init_ams_agent(path)
    
    # Get current services
    log.info('Read existing metadata file at ' + config['metadata'])
    services_data = subprocess.run(['php', '-r', 'echo json_encode(include "'+config['metadata']+'");'], universal_newlines=True, stdout=subprocess.PIPE)
    services_json = json.loads(services_data.stdout)
    if not isinstance(services_json, list):
        log.error('Cannot read metadata php file')
        exit(1)
    
    # Get messages
    while True:
        log.info('Pull messages from ams')
        messages, ids = ams.pull(1)
        ams.ack(ids)
        log.info('Received ' + str(len(messages)) +' messages from ams')
        if len(messages)>0:
            services_json = update_data(services_json, messages)
            generate_config(services_json, config['metadata'])
            log.info('Run sync http request to ' + config['ssp_url'])
            payload = {'key': config['metadata_key'], 'tag': 'hourly'}
            requests.get(config['ssp_url'], params = payload)
        time.sleep(config['time_interval'])

    log.info('Exit script')
