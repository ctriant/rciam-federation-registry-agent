#!/usr/bin/env python3

import json, time
import subprocess
import argparse
import requests
import logging
from Utils.common import get_log_conf, create_ams_response
from Utils.xrdparser import XRDParser
from ServiceRegistryAms.PullPublish import PullPublish

log = logging.getLogger(__name__)

'''
This function will update the XRD metadata repository according to the incoming messages 
and will return a list with the update result for each distict message.
    Function update_data gets one argument:
    - messages, the new incoming messages in json
'''
def update_metadata_repository( messages, agent_id):
    args = {"id": "", "url":"", "rel": "urn:oasis:names:tc:SAML:2.0:metadata",
            "agent_id": agent_id}
    responses = []
    for msg in messages:
        response = {"id": msg['id'], "agent_id": agent_id, "status": 200}
        if msg['deployment_type'] == 'create':
            log.info('Create service: ' + str(msg['id']))
            args['id'] = str(msg['id'])
            args['entity_id'] = msg['entity_id']
            args['url'] = msg['metadata_url']
            try:
                xrdparser.append(**args)
            except RuntimeError:
                response["state"] = "error"
                response["status"] = 500
                responses.append(response)
            else:
                response["state"] = "deployed"
                responses.append(response)
        elif msg['deployment_type'] == 'edit':
            log.info('Update service: ' + str(msg['id']))
            args['id'] = str(msg['id'])
            args['entity_id'] = msg['entity_id']
            args['url'] = msg['metadata_url']
            args['service_name'] = msg['service_name']
            try:
                xrdparser.update(**args)
            except RuntimeError:
                response["state"] = "error"
                response["status"] = 500
                responses.append(response)
            else:
                response["state"] = "deployed"
                responses.append(response)
        elif msg['deployment_type'] == 'delete':
            log.info('Delete service: ' + str(msg['id']))
            try:
                xrdparser.delete(str(msg['id']))
            except RuntimeError:
                response["state"] = "error"
                response["status"] = 500
                responses.append(response)
            else:
                response["state"] = "deployed"
                responses.append(response)
    return responses

def publish_ams(ams_agent, responses, messages, agent_id):
    pub_messages = []
    for idx, message in enumerate(messages):
        msg = create_ams_response(responses[idx], message['id'], agent_id, -1, '')
        pub_messages.append({'attributes':{},'data': msg})
    print(pub_messages)
    ams_agent.publish(pub_messages)


if __name__ == '__main__':
    # Get config path from arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', required=True, type=str, help="Script configuration file path")
    args = parser.parse_args()
    path = args.c
    with open(path) as json_data_file:
        config = json.load(json_data_file)
    
    xrdparser = XRDParser(config['saml']['metadata_conf_file'])

    # Get log_conf from project arguments else use the global setting
    if 'log_conf' in config['saml']:
        get_log_conf(config['saml']['log_conf'])
    else:
        get_log_conf(config['log_conf'])

    log.info('Init ams agent')
    ams = PullPublish(config['saml']['ams'])

    # services_json = get_services_from_conf(config['ssp']['metadata_conf_file'])
    # Get messages
    #with open('/home/ctriant/messages.json') as json_file:
    #    messages = json.load(json_file)

    while True:
        messages, ids = ams.pull(1) 
        if len(messages)>0:  
            log.info('Pull messages from ams')
            ams.ack(ids)
            log.info('Received ' + str(len(messages)) +' messages from ams')
            log.info('Messages:' + str(messages) + str(ids))
            responses = update_metadata_repository(messages,
                                                   config["saml"]["ams"]["agent_id"])
            # generate_config(services_json, config['ssp']['metadata_conf_file'])
            # response = call_ssp_syncer(config['saml']['cron_url'], config['ssp']['cron_secret'], config['ssp']['request_timeout'], config['ssp']['cron_tag'])
            publish_ams(ams, responses, messages, config['saml']['ams']['agent_id'])
        # Change this to pyFF interval
            time.sleep(config['saml']['ams']['poll_interval'])
            print(responses)
    log.info('Exit script')
