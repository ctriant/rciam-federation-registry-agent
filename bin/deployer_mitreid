#!/usr/bin/env python3

import json, time
import argparse
import logging
from common import get_log_conf
from ServiceRegistryAms.PullPublish import PullPublish
from MitreidConnect.MitreidClientApi import mitreidClientApi
from Utils.oauth import refreshTokenGrant

# Setup logger
log = logging.getLogger(__name__)


# Initialize ams agent
def init_ams_agent(path):
    log.info('Init ams agent')
    with open(path) as json_data_file:
        config = json.load(json_data_file)
    return PullPublish(config)


# format_mitreid_msg gets a message from ams rciam-federation in snake_case
# and modifies it to camelCase format to be acceptable from mitreID API
def format_mitreid_msg(msg):
    msgNew = {}
    emails=[]
    for key in msg.keys():
        components = key.split('_')
        new_key = components[0] + ''.join(x.title() for x in components[1:])
        msgNew[new_key] = msg[key]
    for contact in msg['contacts']:
        emails.append(contact['email'])
    msgNew['contacts'] = emails
    msgNew['clientName'] = msgNew.pop('serviceName')
    msgNew['clientDescription'] = msgNew.pop('serviceDescription')
    return msgNew


# create_ams_response creates a json object with the result of the mitreId api call
# that is readable from the rciam-federation-registry
def create_ams_response(response, service_id, agent_id, external_id):
    msgNew = {}
    msgNew['id'] = service_id
    msgNew['agent_id'] = agent_id
    if external_id>0:
        msgNew['external_id'] = external_id
    if response is None:
        msgNew['state'] = "error"
    else:
        msgNew['state'] = "deployed"
    return  msgNew


# This function will gain an access token from the provided issuer and it will
# make a POST request using mitreidClient to update or create the client
#    Function update_data gets 3 arguments:
#    - messages, the new incoming messages in json
#    - issuer_url, the url of the issuer
#    - access_token
#    - agent_id
def update_data(messages, issuer_url, access_token, agent_id):
    pub_messages = [] # messages to be published
    mitreid_agent = mitreidClientApi(issuer_url, access_token) # Create mitreid agent
    for msg in messages:
        log.debug('Message from ams: ' + str(msg))

        service_id = msg.pop('id')    # Remove rciam service id to make request to mitreId
        external_id = -1
        mitreid_msg = format_mitreid_msg(msg)    # Format message in camelCase for mitreId
        log.debug('Formated message for mitreId: ' + str(mitreid_msg))
        response = {}
        try:
            if 'externalId' not in mitreid_msg:  # externalId value should be empty if service is no
                log.info('Create new client')
                response = mitreid_agent.createClient(mitreid_msg)
                if 'id' in response:
                    external_id = response['id'] # response['id'] from mitre API is the external id
            else:
                external_id = mitreid_msg['externalId']
                if mitreid_msg['deleted'] == True:
                    log.info('Delete client with id: ' + str(external_id))
                    response = mitreid_agent.deleteClientById(external_id)
                else:
                    log.info('Update client with id: ' + str(external_id))
                    response = mitreid_agent.updateClientById(external_id, mitreid_msg)
            log.info('Message received from mitreId: ' + str(response))
            ams_message = create_ams_response(response, service_id, agent_id, external_id)
        except:
            log.critical('Exception catch, return error to ams')
            ams_message = create_ams_response(None, service_id, agent_id, external_id)

        pub_messages.append({'attributes':{},'data':ams_message})
    if len(pub_messages)>0:
        log.info('Publish messaged to ams')
        log.debug('Messages published to ams: ' + str(pub_messages))
        ams.publish(pub_messages)


if __name__ == '__main__':
    # Get config path from arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', required=True, type=str, help="Configuration file location path")
    args = parser.parse_args()
    path = args.c
    with open(path) as json_data_file:
        config = json.load(json_data_file)
    get_log_conf(config['log_conf'])

    ams = init_ams_agent(path)
    
    # Get messages
    while True:
        log.info('Pull messages from ams')
        messages, ids = ams.pull(1)
        log.info('Received ' + str(len(messages)) +' messages from ams')
        if len(messages) > 0:
            access_token = ''
            try:
                log.info('Get access token from ' + config['mitreid_url'])
                access_token = refreshTokenGrant(config['mitreid_url'], config['mitreid_refresh_token'], config['mitreid_client_id'], config['mitreid_client_secret'])
                ams.ack(ids)
            except:
                log.critical('Failed to get access token')
                raise SystemExit(1)
            update_data(messages, config['mitreid_url'], access_token, config['agent_id'])
        time.sleep(config['time_interval'])
    log.info('Exit script')